# 8. 참조 자료형 (정리중 🤓)
## 참조 자료형 (Reference Type)

기본형 이외에는 전부 참조 자료형이다. (byte, int, long, float, double, char, boolean을 제외한 모든 값)
하나 알아야할 사실은 `String, 배열`도 참조 자료형이다. 

참조 자료형은 우리가 class로 만들어서 사용할 수 있다. class 이름이 참조 자료형이 된다.

참조 자료형은 new 연산자를 통해서 생성할 수 있다.

```java
MyClass myClass = new MyClass();
```

### **참조 자료형의 참조 변수는 참조 값을 가진다.**

참조값이란? Heap 영역에 저장되는 참조 자료형의 값이 저장되는 공간을 가리키는 값을 말한다.
객체는 Heap 영역에 생성되지만, 참조 변수는 Stack영역에 생성된다. 참조 변수 안에는 Heap에 있는 객체를 찾아갈 수 있는 정보가 들어 있다.

- 참조 값은 주소 값이 아니다.
참조 값은 JVM이 관리하는 객체 식별 정보이다. 내부적으로는 주소와 연관되지만, C언어에서 말하는 그 물리 주소 값은 아니다.
GC 이동, 압축 때문에 실제 물리 주소 그대로 노출되지 않는다.

### **참조 값 개념이 중요한 이유? Pass by value, Pass by reference**

사실 먼저 말하면, 자바는 Pass by reference를 하지 않는다.

그래도 이 개념은 중요하다. 이에 두 개념은 메서드 호출 시 매개변수로 넘겨주는 값에 동작 방식을 말한다.

**Pass by value란?**
메서드 매개변수로 값을 넘겨줄 때 값을 복사해서 넘겨주는 방식이다.

```java
public void passByValue(int a) {
	a = 1;
	System.out.println(a); // 1
}
```

위와 같은 메서드가 선언되어 있을 때,

```java
int a = 0;
passByValue(a);
System.out.println(a); // 2
```

1과 2의 출력 값은?

```java
1
0
```

출력 값을 보면 1은 이해가 가지만, 2는 이해가 안간다. 위에서 값을 복사해서 넘긴다고 했다. 이 부분을 잘 생각해보면, 매개변수로 받은 값은 메서드 바깥에 있는 a변수의 값이 아니라 매개변수 a의 값이다. 매개변수는 a의 값을 받은 거지 a라는 변수를 받은게 아니다. 한마디로 메서드 바깥 변수 a와 메서드 매개변수 a는 연동된게 아니다.

그래서 a와 a는 따로 놀기 때문에 메서드 안에 값은 1, 메서드 바깥에 변수 a는 0이 나온 것이다.

**Pass by reference란?**

매개변수에 주소 값을 복사해서 던저누는 방식을 말한다. 주소값이란, heap 영역에 어느 한 공간에 할당된 값의 위치를 의미한다.

다음 예시를 보자.

```java
public void passByReference(String ex) {
	ex = "바뀜";
	System.out.println(ex); //1
}
```

```java
String ex = "바뀌기전";
passByReference(ex);
System.out.println(ex); //2
```

결과는?

```java
바뀜
바뀜
```

(실제 결과는 다르니 오해하지 않길…)

2의 값이 바뀌었다는 것을 알 수 있다. 즉, Pass by reference는 **주소 값**을 전달하기 때문에 메서드 안에서도 같은 Heap 영역을 가리키게 되는 것이다. 그래서 바뀐다.

**그러면 왜 자바는 Pass by reference가 아닌가?**

자바는 항상 값에 의한 전달만 한다. 참조 타입은 그 “값”이 객체 자체가 아니라 참조 값이다. 그래서 참조 값(객체를 가리키는 값)이 복사되어 매개변수로 들어간다.

```java
class Person {
    String name;
    Person(String name) { this.name = name; }
}

static void changeName(Person p) {
    p.name = "B";
}

public static void main(String[] args) {
    Person p1 = new Person("A");
    changeName(p1);
    System.out.println(p1.name); // B
}
```

출력은 B가 찍힌다. 왜 그럴까? Pass by Value인데?

1. p1은 스택 변수, 값은 참조 값
2. new Person(’A’) 객체는 힙에 있다.
3. changeName(p1)을 호출 시에
    1. p1의 값(참조 값)을 복사해서 메서드의 매개변수 p에 넣는다.
4. 이제 p도 같은 참조 값을 들고 있게 된다. p1, p는 같은 객체를 가르킴
5. [p.name](http://p.name) = “B” 는 같은 객체의 인스턴스 변수 name을 “B”로 바꿈
    
    → 즉, P1의 name 값도 같은 객체이니 값이 똑같이 변경됨
    

정리 하자면 바뀐건 p가 아니라 힙에 있는 객체의 내부 필드이다. 그래서 외부에도 동일하게 보인다.

다른 예시를 보자.

```java
static void reassign(Person p) {
    p = new Person("C");
}

public static void main(String[] args) {
    Person p1 = new Person("A");
    reassign(p1);
    System.out.println(p1.name); // A
}
```

출력은 A이다.

호출 시점에 p1의 참조 값이 p로 복사됐다. 하지만 p1과 p는 같은 변수가 아니다.

- ressign 내부에서 `p = new Person(”C”)`를 하게 되면
    - p가 들고 있던 참조 값만 새로운 객채의 참조 값으로 할당 받은 것이다.
    - p는 다른 객체를 가르키게 된다.
- p1은 여전히 가지고 있던 참조 값을 가지고 있다.

### 흔히 하는 오해

참조를 넘기니까 참조에 의한 전달이지 않냐고 할 수 있지만, Pass by reference라면?

> 메서드 안에서 매개변수를 다른 객체로 바꾸면, 
호출자 변수도 같이 다른 객체를 가리켜야한다.
> 

결과도 같으니 더 오해를 할 수 있지만, 과정(동작)을 이해해야 한다.

### 더 정확히 이해하기 위해 C언어랑 비교해보자.

```java
void inc(int* x) {
    (*x)++;
}

int main() {
    int a = 10;
    inc(&a);
    printf("%d", a); // 11
}
```

C는 변수의 주소 값을 전달할 수 있다. `&a` 는 변수 a의 주소 값을 말한다. 그래서 매개변수로 전달받은 x는 **변수 a <<** 를 말한다. 그렇기 때문에 a가 하나 증가된 11이 된다.  
(C를 어려워 하는 이유 중 하나…. 포인터)

## 이러한 방식들을 알아야하는 이유?
자바는 왜 참조 값을 넘기는 방식을 선택했을까?
JVM 메모리 관리 방식? 하나의 가상화 시스템?
주소 값을 넘기게 되면 메모리 관리가 어려워진다. GC가 객체를 이동시키거나 압축할 때 주소 값이 바뀌게 되는데, 주소 값을 넘기게 되면 메서드 안에서 참조하는 주소 값이 바뀌게 된다. 그래서 자바는 참조 값을 넘기는 방식을 선택했다.

## 이러한 방식들을 알아야하는 이유?

### pass by reference의 단점

1. **호출자 변수 자체가 오염된다.**
    - Pass by reference는 함수 내부에서 호출자 상태를 직접 변경
    - 코드 추적이 어려워진다.
    - 사이드 이펙트가 함수 시그니처에 드러나지 않는다.
2. 별칭 폭발!

   만약 참조 자체를 넘기게 된다면 누가 참조를 바꾸는지 추적이 어려워진다.
   그래서 객체 그래프 전체가 예측 불가능해진다.

   자바는 객체 상태 변경은 허용하지만, 객체 자체는 호출자 책임이다.


> **별칭 폭발**
하나의 객체나 참조를 가리키는 경로가 함수, 모듈, 스레드를 거치며 기하급수적으로 늘어나 어떤 코드가 상태를 변경했는지 추적할 수 없게 되는 현상이다.

**pass by reference까지 허용되면**
>
>
> ```java
> void swap(Person p) {
> 	p = new Person("B");
> }
> ```
>
> - 이게 여러번 반복되게 된다면 어떤 메서드가 어떤 조건에서 참조를 다른 객체로 바꿨는지 알 수 없다.
>
> **실무에서 중요한 이유**
>
> 실무에서 문제가 생기면 대충 도메인 값 하나만으로 어디서 바뀌는지 예상하고 있어야 문제를 발견하기 쉽다. 로그에 보이는 결과를 가지고 추적을 시작하기 때문에 코드를 보더라도 이렇게 눈에 보이지 않으면 빨리 문제를 발견할 수 없다.
>
> 만약 멀티 스레드에서라면..?
>
1. GC 관점에서의 이유

   자바의 참조 값은 GC가 객체를 이동시켜도 깨지지 않는 핸들이다.

   주소를 넘기게 된다면?

    - GC가 객체를 이동할 수 없다.
    - 힙 단편화 증가
    - 성능 급락
    - JVM 구현 복잡도가 폭증한다.

   이를 쉽게 이해하려면 가상화 방식 생각하면 된다.

2. 보안

   자바는 초기에 브라우저 애플릿을 목표로 했다

    - 악성 코드가 메모리 주소를 조작한다면, 시스템 크래쉬, 정보 탈취 문제가 생긴다.

   참조 값 모델은 주소 연산 불가, 임의 메모리 접근 불가하게 된다.