# 8. 참조 자료형 (정리중 🤓)
## 참조 자료형 (Reference Type)

기본형 이외에는 전부 참조 자료형이다. (byte, int, long, float, double, char, boolean을 제외한 모든 값)
하나 알아야할 사실은 `String, 배열`도 참조 자료형이다. 

참조 자료형은 우리가 class로 만들어서 사용할 수 있다. class 이름이 참조 자료형이 된다.

참조 자료형은 new 연산자를 통해서 생성할 수 있다.

```java
MyClass myClass = new MyClass();
```

### **참조 자료형의 참조 변수는 참조 값을 가진다.**

참조값이란? Heap 영역에 저장되는 참조 자료형의 값이 저장되는 공간을 가리키는 값을 말한다.
객체는 Heap 영역에 생성되지만, 참조 변수는 Stack영역에 생성된다. 참조 변수 안에는 Heap에 있는 객체를 찾아갈 수 있는 정보가 들어 있다.

- 참조 값은 주소 값이 아니다.
참조 값은 JVM이 관리하는 객체 식별 정보이다. 내부적으로는 주소와 연관되지만, C언어에서 말하는 그 물리 주소 값은 아니다.
GC 이동, 압축 때문에 실제 물리 주소 그대로 노출되지 않는다.

### **참조 값 개념이 중요한 이유? Pass by value, Pass by reference**

사실 먼저 말하면, 자바는 Pass by reference를 하지 않는다.

그래도 이 개념은 중요하다. 이에 두 개념은 메서드 호출 시 매개변수로 넘겨주는 값에 동작 방식을 말한다.

**Pass by value란?**
메서드 매개변수로 값을 넘겨줄 때 값을 복사해서 넘겨주는 방식이다.

```java
public void passByValue(int a) {
	a = 1;
	System.out.println(a); // 1
}
```

위와 같은 메서드가 선언되어 있을 때,

```java
int a = 0;
passByValue(a);
System.out.println(a); // 2
```

1과 2의 출력 값은?

```java
1
0
```

출력 값을 보면 1은 이해가 가지만, 2는 이해가 안간다. 위에서 값을 복사해서 넘긴다고 했다. 이 부분을 잘 생각해보면, 매개변수로 받은 값은 메서드 바깥에 있는 a변수의 값이 아니라 매개변수 a의 값이다. 매개변수는 a의 값을 받은 거지 a라는 변수를 받은게 아니다. 한마디로 메서드 바깥 변수 a와 메서드 매개변수 a는 연동된게 아니다.

그래서 a와 a는 따로 놀기 때문에 메서드 안에 값은 1, 메서드 바깥에 변수 a는 0이 나온 것이다.

**Pass by reference란?**

매개변수에 주소 값을 복사해서 던저누는 방식을 말한다. 주소값이란, heap 영역에 어느 한 공간에 할당된 값의 위치를 의미한다.

다음 예시를 보자.

```java
public void passByReference(String ex) {
	ex = "바뀜";
	System.out.println(ex); //1
}
```

```java
String ex = "바뀌기전";
passByReference(ex);
System.out.println(ex); //2
```

결과는?

```java
바뀜
바뀜
```

(실제 결과는 다르니 오해하지 않길…)

2의 값이 바뀌었다는 것을 알 수 있다. 즉, Pass by reference는 **주소 값**을 전달하기 때문에 메서드 안에서도 같은 Heap 영역을 가리키게 되는 것이다. 그래서 바뀐다.

**그러면 왜 자바는 Pass by reference가 아닌가?**

자바는 항상 값에 의한 전달만 한다. 참조 타입은 그 “값”이 객체 자체가 아니라 참조 값이다. 그래서 참조 값(객체를 가리키는 값)이 복사되어 매개변수로 들어간다.

```java
class Person {
    String name;
    Person(String name) { this.name = name; }
}

static void changeName(Person p) {
    p.name = "B";
}

public static void main(String[] args) {
    Person p1 = new Person("A");
    changeName(p1);
    System.out.println(p1.name); // B
}
```

출력은 B가 찍힌다. 왜 그럴까? Pass by Value인데?

1. p1은 스택 변수, 값은 참조 값
2. new Person(’A’) 객체는 힙에 있다.
3. changeName(p1)을 호출 시에
    1. p1의 값(참조 값)을 복사해서 메서드의 매개변수 p에 넣는다.
4. 이제 p도 같은 참조 값을 들고 있게 된다. p1, p는 같은 객체를 가르킴
5. [p.name](http://p.name) = “B” 는 같은 객체의 인스턴스 변수 name을 “B”로 바꿈
    
    → 즉, P1의 name 값도 같은 객체이니 값이 똑같이 변경됨
    

정리 하자면 바뀐건 p가 아니라 힙에 있는 객체의 내부 필드이다. 그래서 외부에도 동일하게 보인다.

다른 예시를 보자.

```java
static void reassign(Person p) {
    p = new Person("C");
}

public static void main(String[] args) {
    Person p1 = new Person("A");
    reassign(p1);
    System.out.println(p1.name); // A
}
```

출력은 A이다.

호출 시점에 p1의 참조 값이 p로 복사됐다. 하지만 p1과 p는 같은 변수가 아니다.

- ressign 내부에서 p = new Person(”C”)를 하게 되면
    - p가 들고 있던 참조 값만 새로운 객채의 참조 값으로 할당 받은 것이다.
    - p는 다른 객체를 가르키게 된다.
- p1은 여전히 가지고 있던 참조 값을 가지고 있다.

### 흔히 하는 오해

참조를 넘기니까 참조에 의한 전달이지 않냐고 할 수 있지만, Pass by reference라면?

> 메서드 안에서 매개변수를 다른 객체로 바꾸면, 
호출자 변수도 같이 다른 객체를 가리켜야한다.
> 

결과도 같으니 더 오해를 할 수 있지만, 과정(동작)을 이해해야 한다.

### 더 정확히 이해하기 위해 C언어랑 비교해보자.

```java
void inc(int* x) {
    (*x)++;
}

int main() {
    int a = 10;
    inc(&a);
    printf("%d", a); // 11
}
```

C는 변수의 주소 값을 전달할 수 있다. `&a` 는 변수 a의 주소 값을 말한다. 그래서 매개변수로 전달받은 x는 **변수 a <<** 를 말한다. 그렇기 때문에 a가 하나 증가된 11이 된다.
