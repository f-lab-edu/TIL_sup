# 변수
## **변수의 정의부터 다시보자**

> **기본 정의는?**
→ 변하는 값
>

> **추상적으로?**
→ 값을 담아두는 공간
>

> **프로그래밍적으로?**
→ 값을 저장할 수 있는 메모리 공간을 만들고 이름을 붙여, 해당 공간의 값(데이터)을 프로그램 실행 중에 필요에 따라 바꾸거나 참조하여 사용하는 것
>

## 변수의 4가지 종류

```jsx
public class Var {
	int instanceVar; // 인스턴스 변수
	static int classVar; // 클래스 변수
	
	public void method(int paramVar) { // 매개 변수
		int localVar; // 지역 변수
	}
}
```

변수에는 다음과 같은 4가지 종류가 있는데 변수의 종류마다 사용되는 공간 및 유효범위를 잘 알아야한다. 쓰다보면 자연스레 익히게 되긴 하지만, 인스턴스 변수와 클래스 변수의 차이, 지역 변수와 매개 변수의 차이를 헷갈리기도 한다.

> 1. 지역 변수
     지역변수란 중괄호 `{}` 안에 존재하는 변수를 말한다. `{}` 중괄호 안에서만 유효하다.
>

> 2. 매개 변수
     메소드가 호출될 때 생명이 시작되고, 메소드가 끝나면 소멸된다.
>

> 3. 인스턴스 변수
     객체가 생성될 때 생명이 시작되고, 그 객체를 참조하는 다른 객체가 없으면 소멸된다.
>

> 4. 클래스 변수
     클래스가 처음 호출될 때 생명이 시작되고, 자바 프로그램이 끝나면 소멸된다.
>

## 변수의 유효범위

### 지역변수

```jsx
public void method() {
	int a = 0;
	if (true) {
		int b = 1;
	}
	a = b;
	System.out.println(a);
	System.out.println(b);
}
```

지역변수는 중괄호 안에서만 유효하다고 했다. 그래서 다음과 같이 변수 a, b가 있을 때 다음 메소드를 호출하면 컴파일 오류가 난다. b는 if문이라는 중괄호 안에 들어있다. 그래서 if문의 중괄호를 벗어나면 사용할 수 없다. 그 다음 코드를 보면 a에 b의 값을 할당하려고 한다. 하지만, b 변수는 중괄호를 이미 벗어나 a에 b를 할당할 수 없다. 이는 컴파일 오류를 발생시킨다.

### 매개 변수

매개 변수는 어떨까?

```jsx
public void method(int paramVar) {
	System.out.println(paramVar);
	if (true) {
		System.out.println(paramVar);
		if (true) {
			System.out.println(paramVar);
		}
	}
}
```

매개 변수는 메소드 내에 어디에서든 사용할 수 있다. 익명 클래스 또는 Stream 람다 안에서도 매개 변수를 참조할 수 있다. 다만 매개 변수는 타입이 Primitive이거나 Refrence에 따라 달라진다. 이것을 Call by Value, Call by refrence라고 하긴 하는데 자바는 Call by Value만 있기 하다만, 동작이 조금 달라진다.

### 인스턴스 변수

```java
public class IntanceVar {
	public int a;
}
```

인스턴스 변수는 생성자, 메소드 모두 사용할 수 있다. 하지만 static 메소드일 경우에는 사용할 수 없다.

왜 그럴까?

인스턴스 변수는 객체 생성과 이루어진다고 했다. 하지만, static 메소드라면, static이 붙은 것을 생각해보자.
예상한 바와 같이 static 메서드는 객체 생성 여부와 상관 없이 자바가 실행 됐다면 어디서는 호출할 수 있다.(public인 경우) 그런데 객체 생성 후에 사용할 수 있는 인스턴스 변수를 사용한다면 존재하지 않으니 오류가 발생할 수 밖에 없다.

### 클래스 변수

```java
public class VarClass {
	public static int a;
}
```

클래스 변수는 생성자, 메서드 어디에서든 사용할 수 있다. 그리고 public이라면, 클래스 밖에 다른 메소드에서도 접근할 수 있다.

## 자바의 자료형

### 기본 자료형 (Primitive Type)

자바의 기본 자료형은 8개 이다. 빠르게 표로 보는 게 좋다.

| **분류** | **자료형** | **크기** | **표현 범위** | **기본값** | **설명** |
| --- | --- | --- | --- | --- | --- |
| 논리형 | boolean | 1byte* | true / false | false | 조건 판단용 |
| 문자형 | char | 2byte | 0 ~ 65,535 | \u0000 | 유니코드 문자 |
| 정수형 | byte | 1byte | -128 ~ 127 | 0 | 가장 작은 정수 |
|  | short | 2byte | -32,768 ~ 32,767 | 0 | C의 short |
|  | int | 4byte | -2³¹ ~ 2³¹-1 | 0 | **기본 정수 타입** |
|  | long | 8byte | -2⁶³ ~ 2⁶³-1 | 0L | 큰 정수 (L 필요) |
| 실수형 | float | 4byte | 약 ±3.4E38 | 0.0f | 소수점 7자리 |
|  | double | 8byte | 약 ±1.7E308 | 0.0d | **기본 실수 타입** |

자료형을 이해하려면 byte를 먼저 알아야 좋다.

### Byte란 무엇인가?

컴퓨터가 데이터를 0, 1로 다루는 것은 알고 있다. 우리는 0, 1을 2진수라고 하고 이것을 0, 1을 합쳐서 1bit 라고 한다. 이는 컴퓨터의 언어로 우리는 이렇게 한글로 쓰지만 사실은 모두 0, 1로 이루어져 있다. 그래서 Byte란 이 1bit가 8개가 모여진 8bit를 말한다. 그래서 1byte는 8bit 이다.

> 2진수 표현으로 본다면?
0 0 0 0  0 0 0 0
0 0 0 0  0 0 0 1
>

bit의 값이 0으로 모두 채워진다면 그 값은 0이다. 그 다음 값은?

1로 모두 채워져 있으면?
우리는 어렸을 때 배워서 2진수를 10진수로 바꾸는 방법을 알고 있다.

$$
1 \times 2^7+ 1 \times 2^6+ 1 \times 2^5+ 1 \times 2^4+ 1 \times 2^3+ 1 \times 2^2+ 1 \times 2^1+ 1 \times 2^0
$$

10진수로 변환해보면 255가 나온다. 하지만, 1byte 범위를 다시보자. 127까지 밖에 안된다. 그 이유는 음수를 표기하기 위해서다. 컴퓨터에선 음수를 표현할 수 있는 방법으로 1byte 맨 앞에 값이 1이면 음수로 정한 것이다. 그래서 양수 범위가 반토막이 났다.

이제 다시 한번 음수의 범위를 살펴보자. 양수는 127인데 음수는 하나가 더  많은 -128로 되어있다. 왜 그럴까?

비트를 모두 1111 1111 로 채우면 -127이 나오는데 하나가 더 있다. 그 이유는 값을 하나라도 더 제공하기 위해서 고민됐기 때문이다.

0000 0000
1000 0000

우에 두개의 byte를 보면 둘다 0인 것을 볼 수 있다. 이미 0이 있는데 0을 또 표현하긴 좀 낭비라 생각되지 않는가?
→ 그래서 1000 0000 값을 음수의 최소값으로 정한 것이다.

### 형변환

형변환은 주의해서 사용해야 한다. 일단, 형변환이란 변수의 타입을 다른 타입으로 바꾸는 것이다. 형변환은 아주아주아주 자주 사용 되고, 형변환이 되어야 다형성을 설명할 수 있기 때문에 중요하다.

그 만큼 중요하기 때문에 규칙이 있다.

**기본 자료형 변환**

우선 자바에서 명시적으로 선언하지 않아도 자동으로 형변환 해주는 경우가 있다.

1. 작은 범위에서 → 큰 범위

```java
int a = 10;
long b = a;

// long c = (long) a -> 형변환 명시
```

범위가 작은 값에서 큰 범위 값으로 형변환하는 경우에는 (long) 형변환 표시를 해주지 않아도 된다.

1. 큰 범위에서 → 작은 범위

```java
long a = 10;
int b = (int) a;
```

반대인 경우에는 명시적 캐스팅이 필요하다. 하지만,  큰 범위에서 작은 범위로 형변환을 잘 안하는데 그 이유는 데이터 손실이 생길 수 있기 때문이다. 그래서 원래 안되는데 너가 그래도 형변환 하겠다고 하면 해줄게 이런 느낌이다.

1. boolean 형변환

boolean은 어떤 타입과도 형변환할 수 없다.

```java
boolean b = true;
int i = (int) b;
```

> C/C++과 다르게 자바는 논리와 숫자를 완전히 분리한다.
>
1. char 형변환 규칙

char는 문자를 표현할 때 쓴다. ex) ‘A’, ‘B’

**char → 정수 : 자동**

```java
char c = 'A';
int i = c;   // 65
****
```

**정수 → char : 강제**

```java
int i = 65;
char c = (char) i;  // 'A'
```

char는 정수로도 형변환 할 수 있는데 그 이유는 아스키코드, 유니코드 등 문자 체계를 검색해보면 알 수 있다.
char는 부호 없는 2byte 정수이다.

**연산시 자동 형변환 규칙**

1. byte, short, char는 연산 시 무조건 int로 승격

```java
byte a = 10;
byte b = 20;
byte c = a + b;   // 컴파일 에러 (결과는 int)
```

```java
byte c = (byte)(a + b); // ⭕
```

1. 혼합 타입 연산 규칙

가장 큰 타입 기준으로 통일 된다.

```java
byte + int     → int
int + long     → long
long + float   → float
float + double → double
```

```java
int i = 10;
double d = 3.5;
double r = i + d;   // 결과는 double
```

**리터럴 형변환 규칙**

1. 정수 리터럴 기본 타입

```java
10    // int
10L   // long

long l = 10; // (int -> long)
```

1. 실수 리터럴 기본 타입

```java
3.14     // double
3.14f    // float

float f = 3.14;     // X
float f = 3.14f;    // O
```

### 참조 타입(Reference) 형변환

참조형 형변환은 상속과 관련되어있다. 상속을 미리 먼저 알아야 이해할 수 있을 것이다. 그래서 이번에 이런 것도 있구나 하고 알고만 넘어가면 된다.

1. 업캐스팅 (Upcsting)

```java
Animal a = new Dog();
```

업캐스팅은 명시적으로 표시해주지 않아도 자동 형변환 된다. 기본형 타입에서 작은 값에서 큰 값으로 자동 형변환 해주었지만 참조는 반대다.

자식 → 부모

부모가 더 크다고 생각할 수 있지만 사용범위는 자식이 더 크다. 자식이 부모의 변수, 메서드를 사용할 수 있기 때문이다.

1. 다운 캐스팅 (DownCating)

```java
Animal a = new Animal();
Dog d = (Dog) a;
```

명시적으로 표시해줘야 하고, 런타임 오류난다.

부모 → 자식

**다운 캐스팅은 왜 문제가 될까?**

다운 캐스팅이 문제 되는 이유는 부모 객체에는 자식 객체에 필드, 메서드가 없기 때문에 런타임 에러인 ClassCastExcpetion이 발생한다.
부모 객체는 자식으로 변환할 구조 자체가 없다. 없는 걸 사용하라고 하는 것이다.

그러면 왜 컴파일 에러가 아니라 런타임 에러일까?

이는 컾파일러가 알 수 있는 정보부터 살펴봐야한다. 컴파일이 알 수 있는 정보는 다음과 같다.

- 변수의 선언 타입
- 클래스 간 상속 관계
- 문법적 캐스팅 가능 여부

컴파일 시점에는 객체의 실제 타입을 알 수 없다.

```java
Parent p;
```

컴파일러가 아는 사실은 p는 Parent 타입, Parent와 Child의 상속 관계이다.

즉, 실제 객체가 Parent인지 Child인지 모른다. 될 수도 있다는 사실까지만 판단이 된다.

런타임은 실제 객체 타입의 정보까지 알고 있어 타입 검사를 할 수 있다.

```java
void use(Parent p) {
    Child c = (Child) p; // 컴파일 에러 (가정)
}
```

```java
use(new Child());   // 분명히 합법적
```

만약 컴파일 시점에 다운캐스팅을 금지했다면, 위와 같이 실제 객체는 Child이지만 사용할 수 없게 된다.

그래서 자바가 컴파일 시점에 다운캐스팅을 허용한 이유는

컴파일러가 객체의 실제 타입을 알 수 없는 상황에서도 합법적인 다형성 사용을 막지 않기 위해서이며, 최종 타입 검증은 실행 시점의 JVM 책임으로 분리했기 때문이다.

- 업캐스팅: **표현을 줄이는 행위**
- 다운캐스팅: **실체를 되찾는 행위**
- 컴파일러는 실체를 모른다
- JVM만 실체를 안다.