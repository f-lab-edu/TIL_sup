# 05. 조건문과 반복문
## 자바의 조건문

### if, else if, else

```java
if (조건문) {
	구현;
} else if (조건문) {
	구현;
} else {
	구현;
}
```

if문 조건문에 값이 true이만 `{}` 중괄호 안에 코드를 실행하는 제어문이다. 즉, 조건에 해당하면 실행 아니면 `{}` 다음으로 넘어간다.

조건문에는 값이 `true` 또는 `false`가 와야한다. 그래서 비교 연산, 논리 연산이 사용가능하다.
또는 함수 return 값이 boolean이면 사용할 수 있다.

else if, else는 처음 if 조건이 false 이면, 다음 else if로 조건문을 판별하게 되고 실행, 값이 false이면 마지막 else를 무조건 실행한다. else if는 계속해서 사용할 수 있다.

```java
if (조건문) {
	구현;
} else if (조건문) {
	구현;
} else if (조건문) {
	구현;
} else if (조건문) {
	구현;
} else if (조건문) {
	구현;
} else if (조건문) {
	구현;
}
```

### if문 활용

1. 구현부가 한줄일 경우 {} 생략 가능하다.

```java
if (true) System.out.println("Hi");

if (true) 
	System.out.println("Hi");

if (true) return "Hi";
```

1. 중첩으로 사용 가능
무한으로 가능..? 하지만 중첩이 계속 쌓일 수록 가독성 및 디버깅이 힘들다. 중첩은 최대한 안쓰는게 좋음.
(계속 쌓이면 피라미드 지옥이 펼쳐짐…)

```java
if (조건문) {
	if (조건문) {
	
	} else {
	
	}
}
```

1. if문은 보통 1단계에서 끝낼 수 있으면 좋다. 그래서 리팩토링에서는 if문 줄이기라는 내용이 있을 정도이다.
2. Early Return
    
    가독성을 위해 Ealry Return으로 많이 사용한다.
    
    ```java
    public boolean validation(String value) {
    	if (조건...) {
    		return true;
    	}
    	
    	return false;
    }
    ```
    

### Switch문

만약, 하나의 값으로 여러 범위에 걸쳐서 비교해야 할 때는 switch문을 사용하면 좋다.

```java
switch(조건) {
	case 1:
		구현;
		break;
	case 2:
		구현;
		break;
	case 3:
		구현;
		break;
	case 4:
		구현;
		break;
	case 5:
		구현;
		break;
	default;
		break;
}
```

**switch문 사용방법**

1. switch문의 조건에는 long을 제외한 정수형과 몇몇 특별한 타입만이 들어갈 수 있다.
    - long을 제외한 정수 (실수 x)
    - Enum
    - 래퍼 클래스(Byte, Short, Character, Integer, String)
2. case문 끝에는 break; 키워드를 넣어줘야 한다. 그렇지 않으면 다음 case문 까지 가게 된다. 예를 들어
case 2에 break;이 없다고 하고 case2로 들어온다면 case3에 있는 코드까지 실행된다.
만약, break문이 없다면 해당되는 조건부터 전부 훑고 간다.
3. default는 해당되는 case가 없으면 실행된다. else와 비슷
4. 숫자 비교시 작은 숫자부터 큰 숫자부터 증가시켜 가는 것이 좋다.

switch 문을 사용하기 좋은 경우

1. 값이 “동등비교 (==)” 비교 기준일 때
    
    ```java
    switch (status) {
        case READY:
        case DONE:
    }
    ```
    
2. 경우의 수가 명확하고 닫혀 있을 때
    
    ```java
    enum OrderStatus {
        READY, PAID, SHIPPED, CANCELED
    }
    ```
    
    ```java
    switch (orderStatus) {
        case READY:
        case PAID:
    }
    ```
    
3. 같은 변수를 여러 번 비교해야 할 때
    
    ```java
    switch (type) {
        case A:
        case B:
        case C:
    }
    ```
    
4. UI / 상태 / 명령 분기
    
    ```java
    switch (command) {
        case "START":
        case "STOP":
    }
    ```
    
5. Switch expression (Java 14+)
    
    ```java
    String grade = switch (score / 10) {
        case 10, 9 -> "A";
        case 8 -> "B";
        default -> "F";
    };
    ```
    

## 반복문 for, while

반복문은 for, while 두 가지가 있다. 보통은 for문을 많이 쓴다.

### while

while문은 반복 횟수를 사전에 알 수 없을 때 쓰인다.

```java
while (조건문) {
	처리 문장;
}
```

사용은 간단하다. 조건이 true이면 {} 안을 계속 반복한다. 그리고 false가 되면 while문을 탈출한다. 탈출 조건은 다음과 같다.

**탈출 조건**

1. 조건부가 false일 때
2. break;을 만날 때

하지만, whilte문은 위험 요소가 있다. 그 위험 요소가 for문을 많이 사용하는 이유 중 하나이다.

- 무한루프에 빠질 가능성이 있다.
탈출 조건 값을 제대로 주지 않을 경우 무한 루프에 빠지기 쉽다. 이는 **프로그램 멈춤, 시스템 자원 소모, 예기치 않은 동작**을 유발한다.

**사용 예시**

1. 반복 횟수를 모를 때

```java
while (scanner.hasNext()) {
	process(scanner.next());
}
```

1. 특정 상태가 될 때까지 반복

```java
while (!queue.isEmpty()) {
    process(queue.poll());
}
```

- 컬렉션 소진
- 상태 플래그 변경
- 외부 자원 대기
1. 이벤트 / 대기 루프

```java
while (!isConnected) {
    retry();
}
```

1. 재시도 + 제한 횟수

```java
int retry = 0;
while (retry < MAX_RETRY && !success) {
    retry++;
}
```

> while은 **“몇 번 반복할지”가 아니라**
“언제까지 반복할지”를 표현하는 반복문
> 

### for 문

```java
for (int i = 0; i < 10; i++) {
	코드 반복 실행;
}
```

for문도 break;를 사용할 수 있다.
중첩 for문으로도 사용할 수 있다. while 또한 중첩으로 사용 가능하지만, 거의 사용하는 것을 못봤다.
중첩 또는 반복횟수가 명확한 경우는 for문을 사용하는 것이 좋다.

### 향상된 for문

컬렉션이나 리스트를 사용할 때 가능한 for문 변형이 있다.

```java
List<Strng> list = new ArrayList();
for (String value : list) {
	System.out.printlnt(value);
}
```

이러한 경우 list 안에 있는 값을 바로 가져와 사용할 수 있다.

### 기타

요새는 Stream 람다식으로 많이 사용한다. 람다식으로 사용할 경우 의도가 명확해지기 때문에 가독성이 향상된다.

```java
new Comparator<User>() {
    @Override
    public int compare(User o1, User o2) {
        return o1.getAge() - o2.getAge();
    }
}

// 람다식
(a, b) -> a.getAge() - b.getAge()
```

```java
for (User u : users) {
    if (u.isActive()) {
        if (u.getAge() > 20) {
            result.add(u.getName());
        }
    }
}
```

```java
// 람다식
users.stream()
     .filter(User::isActive)
     .filter(u -> u.getAge() > 20)
     .map(User::getName)
     .toList();
```

람다식을 사용하면 이 코드가 무엇을 하는 작업인지 명확해진다. 물론, 항상 명확해지지는 않는다.
아래와 같이 의도가 흐려질 수도 있음

```java
users.stream()
     .filter(u -> u.isActive() && u.getAge() > 20 && u.getScore() > 80)
```

이러한 경우 이름을 부여하면 된다.

```java
.filter(User::isEligible)
```

람다를 설명해야 한다면, 잘 못 사용하는 경우이다.
람다를 보고 **머릿속으로 이렇게 읽히면 성공**이다.

> “~한 작업을 한다”
> 

반대로 이렇게 읽히면 실패다.

> “어… 이걸 한 번 풀어봐야겠는데?”
>