# 6. 배열 (정리중)

## 자바의 배열

**자바에서 배열을 다루는 방식**

```java
// 선언
int [] arr;
int arr[];

// 선언 및 초기화
int [] arr = {1,3,4}
int [] arr = new int[7];
arr[0] = 1;

// 사용
int arrValue = arr[0];
```

**2차원 배열 (다차원)**

```java
int [][] arr;
int arr[];

int [] arr = {
	{1, 2, 3},
	{2, 3, 4}
};
int [][] arr = new int[4][4];
int [][] arr2 = new int[7][];
arr2[0] = new int[3];
arr2[1] = new int[5];
```

### for루프를 이용한 배열 사용

배열 객체 내부에서 요소들이 연속적으로 배치된다. 그래서 index로 접근이 가능하고, for와 같은 반복문을 통해서 배열을 효율적으로 다룰 수 있다.

```java
int arr = new arr[10];
for (int i = 0; i < arr.length; i++ {
	arr[i] = i;
}
```

또한, 향상된 for문을 사용할 수 있다. 이 for문은 JDK 5부터 사용할 수 있게 됐다.

```java
for (int number : arr) {
	System.out.println(number);
}
```


### 배열의 특징

1. 배열 객체 내부에서 요소들이 연속적으로 배치된다.
2. 인덱스를 통해 접근이 가능하다.
3. 자바에서 배열은 객체이다.
4. 배열의 길이는 가변적이지 않다. 한번 정해진 길이는 다시 초기화 해서 사용해야 한다. 가변적인 배열을 사용하려면 Collection을 이용해야 한다.

자바에서 배열은 기본 타입처럼 그냥 선언과 동시에 할당에서 쓰이긴 하지만 객체이다. 객체라는 증거는 여러가지가 있다.

1. 배열을 출력배호면 참조값이 나온다. 이는 `Object`를 상속받고 있고, `toString()`, `hasCode()`를 사용하고 있기 때문이다.
`[Ljava.lang.String;@5e34d46a`
    
    배열안에 요소를 출력하고 싶으면, `java.util.Arrays.toString`을 이용하면 된다.
    
2. `new` 연산자를 사용한다.
3. `arr.length` 같은 속성을 사용할 수 있다. (하지만 자바 필드는 아니며 JVM 메타데이터이다.)
4. 배열은 런타임 시점에 힙 영역에 생성된다. 이를 가르키는 참조 변수를 통해 접근할 수 있다.
5. 객체 연산이 가능하다. `instanceof` 연산자를 사용해서 배열 타입을 확인할 수 있다.
6. `getClass()`로 배열의 클래스 정보를 알 수 있다.

그렇다고 `java.lang.reflect.Array`는 배열이 아니다. 그냥 유틸리티인 다른 클래스다. (정적 헬퍼 메서드만 제공)

### JVM과 배열

> 자바에서 배열이 객체인 이유는 JVM이 힙 기반 객체 모델 하나로 GC, 타입 정보, 참조 추적을 통합 관리하기 위해서이며 배열을 예외로 두는 순간 JVM 복잡도가 급격히 증가하기 때문이다.
> 

> 배열을 객체로 만든 이유는 JVM이 힙/참조/타입정보/GC라는 객체 모델로 메모리 관리를 통일하기 위해서고, 동시에 배열은 전용 바이트코드와 연속 메모리 배치를 통해 기본타입처럼 빠르게 동작하도록 특수 최적화되어 있다.
> 

**객체가 갖는 특징**

- 힙 메모리에 생성됨
- 참조 변수로 접근
- 객체 헤더를 가짐
- GC 관리 대상
- 런타임 타입 정보 공유

**JVM이 배열을 객체로 만들면 얻는 이점**

1. GC 관점
    - 배열도 참조 그래프의 한 노드
    - 객체 스캔 로직을 그대로 재사용 가능
    - 배열도 런타임 타입을 가지게 됨
2. 타입 시스템 관점
    - 공변성(String[] is Object[]) 지원
    - `Class` 객체로 메타데이터 관리 기능
3. 명령어 관점 (bytecode)
    - JVM은 배열 전용 명령어조차 객체 모델 위에서 동작한다.

JVM이 배열을 기본 메모리 블록으로 구현하게 된다면 위에 얻는 이점이 전부 망가진다.

GC 관리가 어려워진다.  
  → GC는 객체를 추적하며 메모리를 회수한다. 객체가 아니라면 참조 그래프가 깨지고, 배열 안의 참조 스캔 규칙을 다시 세워야 한다.

런타임 타입 안정성이 약해진다.  
  → JVM은 런타임 중에 타입 체크를 해야한다. 배열은 특히 저장할 때 타입 체크가 들어가는데, 객체로 할 경우 가능해진다.
  
참조 모델이 통일되지 않는다.  
  → 자바는 참조 타입은 전부 레퍼런스로 다룬다는 규칙이 강하다. 배열을 예외로 만들면 스택/힙 배치 규칙이 복잡해지고, 바이크코드 및 검증기 규칙도 복잡해진다.

**객체이지만 기본타입 처럼 보이게 만든 이유**

1. 문법적으로 new + 클래스 이름이 없다.
    
    ```java
    new int[];
    new String[]
    ```
    
2. 필드 접근처럼 보이는 length
    
    자바에서 length는 클래스 필드가 아닌 메타데이터 정보이다. 이는 런타임때 정해지며, 그렇기 때문에 불변이다.
    
3. 배열은 메서드 호출이 거의 없다. 실질적으로 배열은 상태 접근, 반복, 인덱싱이 전부이다. 그래서 행위 중심 객체가 아니라 데이터 컨테이너 처럼 보이게 설계했다.
4. 배열은 JVM에서 opcode를 가진다.
→ 성능 최적화를 위해 primitive에 가까운 취급을 한다.

즉,  
- 배열은 성능을 위해서 반드시 빠른 메모리 연속 구조여야 했다.
- 배열은 C 개발자가 와도 바로 쓸 수 있게 만들었다.
- 배열은 JVM 내부 구현 복잡도를 최소화 했다. 
  - 내부 구현은 객체로 통합했다.
  - 외부 문법은 특수 문법으로 단순화했다.

하지만, 단점도 존재한다.

- 배열은 확장하기가 어렵다. 그로인해, 컬렉션 프레임쿼드와 Stream이 등장했다.
- 배열은 OOP적으로 객체인데 역할/책임이 없고, 캡슐화, 다형성도 제한적이다. 그래서 도메인 모델에서는 거의 안 쓴다.
