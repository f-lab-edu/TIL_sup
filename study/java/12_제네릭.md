# 12. 제네릭 (Generics)

제네릭은 타입 형 변환에서 발생하는 문제점을 사전에 방지하기 위해서 만들어졌다.

> **타입 안정성과 유연성을 동시에 잡는 방법**
> 

### 제네릭이 만들어진 이유

제네릭은 **컴파일 타임 타입 안정성(Type Safety)** 을 확보하기 위한 문법이다.

핵심 목표는 단 하나다.

> **형변환(Casting)을 제거하고, 잘못된 타입 사용을 컴파일 단계에서 차단하는 것**
> 

### **제네릭이 없던 시절 (Java 1.4 이전)**

```java
List list = new ArrayList();
list.add("hello");
list.add(123);

String str = (String) list.get(1); // 런타임 에러 발생
```

- 모든 값이 Object
- 강제 형변환이 필요하다
- 런타임에서 ClassCastException이 발생한다.

### 제네릭 기본 문법

```java
List<String> list = new ArrayList<>();
list.add("hello");
// list.add(123); // 컴파일 에러

String str = list.get(0); // 캐스팅 필요 없음
```

- 제네릭을 사용하면 컴파일 단계에서 타입을 체크하게 된다.
- 형변환 명시를 제거할 수 있다.
- 코드 가독성이 향상된다.

### 제네릭 타입 매개변수

| **타입** | **의미** |
| --- | --- |
| T | Type |
| E | Element |
| K | Key |
| V | Value |
| R | Return |

```java
public class Box<T> {
    private T item;

    public void set(T item) {
        this.item = item;
    }

    public T get() {
        return item;
    }
}
```

```java
Box<String> box = new Box<>();
box.set("hello");

String value = box.get();
```

제네릭에 어떤 단어가 들어가도 상관 없으나 위에 표에 있는 타입들을 따르는 것이 좋다.

### 제네릭 메소드

제네릭은 클래스 단위가 뿐만 아니라 메소드 단위에서도 사용 가능하다.

```java
public class Util {

    public static <T> T getFirst(List<T> list) {
        return list.get(0);
    }
}
```

### 제네릭의 핵심 개념 : Type Erasure

자바 제네릭은 컴파일 타임에만 존재한다. 컴파일 이후에는 타입 정보가 제거된다.

```java
List<String> list1 = new ArrayList<>();
List<Integer> list2 = new ArrayList<>();
```

두 객체 모두 런타임에는 `ArrayList` 타입으로 동일하다.
이것을 타입 소거(Type Erasure)라고 한다.

이렇게 하는 이유는 기존 JVM과 호환성을 유지하고, 바이트코드 레벨 변경을 최소화하기 위해서 이다.

### 제네릭 한계

- 기본 타입 사용 불가
- new T() 불가
- instanceof  사용 제한

### 제네릭 상한 제한 (Bounded Type)

**extends (상한)**

```java
public class NumberBox<T extends Number> {
    private T value;
}
```

Number와 Number 하위 타입만 허용 한다.

**다중 제한**

```java
<T extends Number & Comparable<T>>
```

### 와일드 카드

**? extends T**

```java
List<? extends Number>
```

- Number 하위 타입
- 추가는 불가능하다.

**? super T**

```java
List<? super Integer>
```

- Integer 상위 타입
- 추가할 수 있다.
- 꺼낼 때는 Object 형이다.

> PECS:
**Producer → extends
Consumer → super**
> 

### 공변성과 불공변성

```java
List<Integer>  List<Number>
```

두 개는 완전히 다른 타입으로 간주한다.

```java
List<Integer> intList = new ArrayList<>();
List<Number> numList = intList;  // 허용된다고 가정

numList.add(3.14); // Double 추가

Integer value = intList.get(0); // 터짐
```

제네릭은 위와 같은 상황을 막기 위해 불공변이다.

> 반대로 **공변**이란?
하위 타입 관계가 그대로 유지되는 것을 말한다.
> 

```java
Number[] arr = new Integer[10]; // 가능
```

배열은 런타임 체크이기 때문에 가능하지만, ArrayStoreExcpetion이 런타임에 터진다.

제네릭은 컴파일에서 체크하기 때문에 이러한 문제를 막아준다.

### 제네릭 사용시 주의점

---

1. 반환 타입에 와일드카드 쓰지 마라
2. 매개변수에서는 와일드카드 적극 사용
3. public API에서는 타입 안정성 최우선
4. raw type 사용 금지

> raw type 이란
제네릭 타입에서 타입 매개변수를 제거한 타입
List<String>
List → Raw type
>