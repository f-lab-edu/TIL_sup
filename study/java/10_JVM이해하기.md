# 10. JVM 이해하기
## JVM (Java Virtual Machine)

JVM은 자바 애플리케이션이 실행할 수 있는 환경을 제공하는 소프트웨어이다. 자바 기술의 핵심이며, 자바가 플랫폼에 독립적일 수 있는 이유이다. JVM이 OS에 종속되어 있으면서 바이트 코드로된 .class 파일을 가지고 자바 프로그램을 실행할 수 있어 자바는 OS 환경에 종속되지 않을 수 있다. 즉, OS와 우리가 작성한 자바 파일 사이에 JVM이 있고, JVM은 OS마다 맞춰서 구동된다.

- JVM은 구현체이다.
- JVM의 대표적인 구현체는 Hotspot VM이 있다.
- 이러한 구현체들은 JVM 명세를 따른다.

> **JVM 명세**
JVM에는 JVM 명세라는게 존재한다. JVM 명세는 모든 JVM이 갖춰야할 특정 기능들을 정의한 명세서다. 가상 머신 인스턴스의 동작을 서브시스템, 메모리 영역, 데이터 유형 및 명령어로 설명한다. 이러한 구성 요소들은 추상적인 자바 가성 머신의 내부 아키텍처를 나타낸다. 이러한 구성의 목적은 구현체의 내부 아키텍처를 강제하는 것이 아니라, 구현체의 외부 동작을 엄격하게 정의하는 방법을 제공한다.
>

### JVM 역할

JVM 역할은 일단 크게 2가지로 보자.

- 클래스 파일 로드 : 클래스 로더 시스템이 실제로 필요한 자바 API 클래스만 가상 머신에 로드한다.
- 바이트코드 실행 : 실행 엔진이라는 것을 통해 변환된 바이트 코드를 실행

물론 더 하는 일은 많지만, 크게 두가지 역할을 부여 받는다. 즉, JVM에는 크게 클래스를 로드하는 **클래스 로더 시스템**, 로드 된 클래스(바이트 코드)를 실행하는 **실행 엔진**을 가지고 있다.

## 클래스 로더 시스템 (Class Loader Subsystem)

클래스 로더 시스템은 자바 언어를 컴파일한 클래스 파일(바이트 코드)을 실행하기 위해 JVM 메모리(Runtime Data Area)에 적재하는 역할을 한다.

JVM은 런타임 환경에서 클래스가 필요하면 동적(Lazy Loading)으로 로드한다. 실행 시작 시점에 모든 클래스를 로드 하는 것이 아니다. 이는 JVM 설계 초기부터 존재한 기본 동작 원리이고, Oracle 문서 JVM Spec 5장에 명확히 나와 있다.

> **클래스는 ”first active use” 시점에 로딩되고 초기화된다.**
>

JVM이 클래스를 로드하는 과정은 **로딩**, **링킹**, **초기화**라는 3단계를 거친 후 클래스가 JVM의 메모리 영역인 Runtime Data Area에 적재된다.

![img.png](../../image/java/java_10_01.png)

## 로딩 (Loading)

로딩은 .class 파일을 찾고 메모리에 올린다. 로딩 과정은 계층적 구조로 이루어져 위임 모델을 통해 동작한다. 로딩 과정에서 클래스 로더는 부트스트랩, 플랫폼, 애플리케이션(시스템) 클래스 로더가 존재한다. 이는 순서대로 부트스트랩 → 플랫폼 → 애플리케이션 순으로 이루어진다.

### **동작 방식 (Java 9+ 이전)**

1. 프로그램이 특정 클래스를 사용하려고 할 때 클래스 로더가 클래스 로딩을 요청 한다.
2. 클래스 로더는 요청받은 클래스를 직접 로드하기 전에 부모 클래스로더에게 로딩을 위임한다.
3. 부모 클래스 로더들은 자신이 담당하는 경로(라이브러리 등)에서 클래스를 찾는다.
4. 찾지 못하면 하위 클래스 로더에 요청을 전달한다.
5. 클래스를 찾으면 바이트코드를 JVM의 메모리(메소드 영역)로 로드하고, 심볼 링크 연결 등 링크 단계를 거쳐 초기화 한다.
6. 이미 JVM의 메소드 영역에 있다면 로드하지 않고, 기존 것을 사용한다.
7. 클래스 로드 실패시 JVM은 ClassNotFoundException 이나 NoClassDefFoundError 를 발생시킨다.

### **변경된 동작 방식 (JPMS)**

JPMS가 Java 9 버전부터 도입되면서 클래스 로더 방식에도 변경되었다. 기본적인 부모 위임 구조나 계층은 유지되지만, 계층 구성원이 확장 클래스 로더에서 Platform ClassLoder로 바뀌었고, 클래스를 로드 하기전에 모듈 시스템에서 한 번 검증하는 단계가 추가되었다. 즉, 모듈 시스템이 클래스를 로드하기 전에 필터링하는 작업을 하게 된다.

```java
모듈 시스템 (ModuleLayer)
        ↓
ClassLoader Delegation
        ↓
클래스 로딩
```

그러면서 Classpath 기반이 모듈 기반 로딩으로 변경되었다. 둘의 차이점은 다음과 같다.

- Classpath 기반(평면 구조) : 클래스패스는 단순한 파일 목록이다. 즉, 모든 클래스는 같은 공간에 존재하고, jar 간 경계 개념이 없다. 어떤 jar가 어디에 의존하는지도 모르기 때문에 JVM은 단순히 앞에서부터 순차 검색할 수 밖에 없다. 그리고 접근 제어자가 public이면 어디서든 접근이 가능하다.

  이러한 구조는 버전 충돌, split package, 런타임에야 오류를 발견하는 문제점이 생긴다.

- 모듈 기반(그래프 구조) : 모듈 기반은 어떤 클래스라 어떤 곳에 의존하는지 선언하기 때문에 의존성 그래프가 생긴다. 그로 인해 클래스를 로드하기 전에 사전 검증을 할 수 있다. 이는 동일 패키지 중복, split package, public이라도 expert 안 하면 접근이 막히게 된다.
  특히, 예전엔 setAccessible(true)로 JDK 내부나 비공개 멤버를 뚫는 라이브러리가 많았는데, 최근 JDK에선 기본적으로 제한되었고, —add-opens 같은 옵션으로 명시적으로 열어야 한다.

또한 클래스 로더는 로딩, 링킹, 초기화라는 3가지 단계로 동작하는 자세한 건 아래에서 설명하겠다. 우선, 클래스 로더의 종류를 보자.

> split pakage란?
>
- 서로 다른 jar(또는 모듈)에 같은 매키지명이 나뉘어 들어있는 상태를 말한다.
- com.foo 패키지가 a.jar에도 있고 b.jar에도 존재할 경우 Classpath에서는 먼저 찾는 쪽이 이긴다는 우연에 기반하기 때문에 클래스마다 섞여 로드되는 지옥에 빠진다.
- 모듈 기반에선 동일 패키지를 여러 모듈이 제공하려 하면 거부해버린다.

### 클래스 로더 종류

클래스 로더의 종류는 다음과 같다.

![img_1.png](../../image/java/java_10_02.png)

- **부트스트랩 클래스 로더**

  JVM시작시 가장 최초로 실행되는 클래스로더이고, 기본 라이브러리인 `rt.jar`(java 9 이전)를 로드한다. 자바 클래스를 로드하는 것이 아닌, 자바 클래스를 로드할 수 있는 클래스로더와 최소한의 자바 클래스(Object, Class, Classloader)만을 로드한다. 클래스 로더 중 가장 최상위에 위치해 있으며, JVM 구현체의 일부이다. C/C++로 구현되어 있다.

- **플랫폼 클래스 로더 (확장 클래스 로더)**

  부트스트랩 클래스 로더의 자식이며 jre/lib/ext 디렉터리나 java.ext.dirs 환경 변수로 지정된 경로의 확장 라이브러리(.jar 파일 등)들을 로드하는 역할을 한다. 자바 핵심 API 외에 개발자가 추가하는 표준 확장 라이브러리들을 JVM에 로드시킨다.

  **로딩 대상** : $JAVA_HOME/jre/lib/ext 폴더나 java.ext.dirs 시스템 속성으로 지정된 경로의 클래스 파일

- **시스템 클래스 로더 (어플리케이션 클래스 로더)**

  확장 클래스 로더의 하위클래스로, classpath에 지정된 클래스와 JAR파일을 로드한다. 우리가 작성한 클래스와 프로젝트에 추가한 외부 라이브러리를 생각하면 된다.


**클래스 로더는 계층적 구조로 되어있다.**

클래스로더가 계층적 구조를 가지는 이유는 **역할 분담을 통한 효율적인 클래스 관리, 보안 강화, 클래스 충돌 방지**때문이며, 이는 **위임 모델(Delegation Model)**을 통해 작동하여 상위 로더가 먼저 클래스를 찾고 실패 시 하위 로더에게 위임하여 중복 로딩을 막고 필요한 클래스를 안전하게 찾는 데 목적이 있다.

> **위임 모델 (Delegation Model)**:
>
- 클래스 로딩 요청이 들어오면 하위 로더는 바로 로드하지 않고 상위 로더에게 먼저 요청을 위임한다.
- 상위 로더는 자신의 영역에서 클래스를 찾고, 없으면 하위 로더에게 위임하는 방식이다.
- 이 덕분에 부트스트랩 로더가 로드한 핵심 클래스는 애플리케이션 로더가 다시 로드하지 않아 메모리 낭비를 막고 일관성을 유지한다.

> **rt.jar 란?**
>
- Java 9 이전 버전에서 자바 프로그램 실행에 필요한 핵심 라이브러리(String, System 등)들을 담고 있던 압축 파일(.jar)로, run time (런타임)의 약자이며, JRE(Java Runtime Environment)의 `lib` 폴더에 위치했으나 Java 9 부터 모듈 시스템 도입으로 사라지고 여러 모듈로 분리되었다.
- Java 9 버전 이후로는 rt.jar는 사라지고, lib/modules 안에 분리되어있다.

## 링킹 (Linking)

가상 머신의 메모리에 로드되는 걸 시작으로 다시 언로드될 때까지 로딩 → 검증 → 준비 → 해석 → 사용 → 언로딩 과정을 거치는데 이 중 검증, 준비, 해석 단계를 묶어 링킹이라고 한다. 해석 단계는 때에 따라서 초기화 후에 시작할 수 있느나 다른 단계들은 순서대로 진행해야 한다.

### 1. Verify (검증)

검증은 .class 파일이 JVM이 안전하게 실행해도 되는 코드인지 검사하는 단계이다.

바이트 코드는 컴파일러가 만들지만, JVM은 네트워크/외부 입력으로 받은 코드도 실행 가능하다. 보안성과 타입 안정성을 보장하기 위해 검증 단계를 거친다.

검증은 4단계로 나눌 수 있다.

1. 파일 형식 검증
    - magic number 확인
    - class file 구조가 JVM 스팩에 맞는지 확인 (”자바 언어 명세”의 요구 사항을 충족)
    - constant pool 구조가 올바른지 확인
2. 메타데이터 검증
    - 클래스 이름  유효성
    - 부모 클래스 존재 여부
    - final 클래스 상속 여부
    - 인터페이스 구현 규칙 위반 여부
3. 바이트 코드 검증
    - 스택 언더플로우 발생 가능성
    - 타입 불일치
    - 초기화되지 않은 변수 접근
    - 접근 제어 위반
    - 잘못된 jump
      바이트 코드에는 goto, if_xxx, tableswitch, lookupswitch, jsr/ret 이라는 분기 명령이 있다. 이 명령들은 모두 특정 오프셋으로 점프하는데 이러한 분기 처리가 잘못될 경우 검증 실패 처리를 한다.
4. 심볼 참조 기본 검사
    - constant pool의 참조가 유효한 방식인지 확인
    - 존재 여부는 Resolve 단계에서 확인한다.

검증은 한 번 이루어진 클래스는 다시 안한다. JIT 컴파일 이후에는 타입 안전을 가정하며 일부 trusted class는 빠르게 통과한다.

- **`-Xverify:none`** 매개 변수 지정

### 2. Prepare (준비)

준비는 클래스가 필요로 하는 메모리를 할당하고, 클래스에 정의된 필드, 메서드, 인터페이스들을 나타내는 데이터 구조를 준비한다.

클래스 변수를 메모리에 할당하고 초깃값을 설정하는 단계로 개념적으로는 이 변수들이 사용하는 메모리를 메서드 영역에 할당해야 하지만, 메서드 영역 자체가 논리적인 영역임을 감안해야 한다. 준비 단계에선 혼란스러운 개념이 두가지 등장하는데 인스턴스 변수가 아닌 클래스 변수만 할당이 된다. 준비 단계에서 클래스 변수에 할당하는 초기값은 해당 데이터 타입의 제로 값이다.

### 3. Resolve (해석)

해석 단계는 JVM이 Constant pool에 있는 심볼릭 참조를 직접 참조로 변환하는 과정이다. JVM은 동적으로 필요할 때만 클래스와 메소드를 동적으로 할당한다고 했다. 이때 로드된 클래스의 참조는 실제 메모리 주소가 아닌 심볼릭 참조로 저장된다.

해석은 클래스, 인터페이스, 필드, 클래스 메소드, 인터페이스 메소드, 메서드 타입, 메서드 핸들, 호출 사이트 지정자의 심볼릭 참조에 대해 수행된다.

- 심볼릭 참조 : 이름이나 경로를 사용하여 참조하는 방식이다. 메모리 주소를 직접 사용하지 않고, 논리적인 식별자를 이용한다.
- 직접 참조 : 실제 메모리 주소를 사용하여 참조하는 방식이다. 심볼릭 참조를 해결한 뒤, 해당 이름에 대한 메모리 주소를 찾으면 이 참조는 직접 참조로 변환된다. 이후 프로그램은 주소를 통해 해당 클래스나 메소드, 데이터를 직접 접근할 수 있다.

## 초기화 (Initialize)

초기화는 클래스 로딩의 마지막 단계로, 사용자 정의 클래스 로더를 이용해 앞어 소개한 단계 중 일부를 제어할 수 있지만, 초기화 대부분의 작업은 JVM이 통제한다. JVM은 사용자 클래스에 작성된 자바 프로그램 코드를 실행하기 시작한다. 이 단계에서 클래스 변수와 기타 자원이 개발자가 작성한 프로그램 코드에 따라 초기화 된다.

- 초기화 단계는 <clinit>() 메소드를 실행하는 과정이다. 자바 컴파일러가 자동으로 생성하는 메소드로, 개발자가 직접 자바 코드를 작성할 수 없다.
- static 필드가 실제 값으로 설정되는 단계이고, static 초기화 블록이 실행된다. 초기화는 클래스가 로드될 때 한 번만 수행되며, 이 과정이 끝나야 클래스가 완전히 준비된 상태가 된다.

## 실행 엔진

실행 엔진은 메모리에 적재된 클래스(바이트 코드)들을 기계어로 변환하여 명령어 단위로 실행한다. 바이트 코드를 운영체제에 맞게 해석하는 역할을 수행하고, 구현 방식에 따라 다양하다.

> 바이트 코드 : OpCode와 추가 피연산자로 이루어져 있다.
>
- 인터프리터 : 바이트코드 명령어를 하나씩 읽어서 해석하고 실행한다. 하나씩 해석하고 실행하기 때문에 바이트 코드 하나하나의 해석은 빠르나 인터프리팅 결과의 실행은 느리다.
- JIT(Just-In-Time) 컴파일러 : 인터프리터의 단점을 보완하기 위해 도입되었다. 인터프리터 방식으로 실행하다가 실행 횟수가 임계점에 도달하면 바이트코드 전체를 컴파일하여 네이티브 코드로 변경하고, 이후 해당 메서드를 더 이상 인터프리팅하지 않고 직접 실행하는 방식이다. 네이티브 코드는 캐시에 보관하기 때문에 한 번 컴파일된 코드는 계속 빠르게 수행되게 된다.
- adaptive optimizer

JIT 컴파일러는 컴파일하는 과정이 오래걸리기 때문에 자주 실행되는 코드만 컴파일하는 방식으로 동작하는 것이다. 만약, 한번만 수행한다면 굳이 오래걸리는 과정을 단 한번을 실행을 위해 한다면 효율적이지 않기 때문이다.

실행 엔진이 어떻게 동작하는지는 JVM 명세에 규정되어있지 않아서, JVM을 구현하는 벤더들은 실행 엔진을 다양하게 구현하고 있다.

### HotSpotVM

HotSpotVm은 JVM 명세에 따라 구현해놓은 구현체이다. 그래서 클래스 로더 시스템, 런타임 데이터 영역, 실행엔진을 모두 구현한다. 그 중에서 실행엔진이 **HotSpotVM**의 핵심이라 할 수 있다.

HotSpotVM은 처음에는 인터프리팅 방식으로 최적화 없이 코드를 실행한다. 그리고 각 메서드의 호출 회수를 기록하고, 그 횟수에 따라 해당하는 메서드를 JIT 컴파일러로 컴파일한다. 즉, 내부적으로 프로파일링을 통해 가장 컴파일이 필요한 부분을 찾아낸 다음 JIT 컴파일러로 컴파일을 하는 것이다. 그래서 핫스팟은 가장 자주 실행되는 곳을 찾아 최적화를 진행한다고 해서 핫스팟이라 지어졌다. 핫스팟은 Java 1.3부터 기본 VM으로 사용되어 왔다.

핫스팟은 높은 성능과 확장성을 제공한다. 핫스팟은 레고처럼 VM 런타임에 GC방식과 JIT 컴파일러를 끼워 맞춰 사용할 수 있다. 이를 위해서 VM 런타임은 JIT 컴파일러용 API와 GC용 API를 제공한다.

핫스팟은 서버, 클라이언트 VM으로 나뉘어 있고, 각각 다른 JIT 컴파일러를 사용한다.

- 클라이언트 컴파일러(C1) : 코드 최적화는 덜하지만 즉시 시작되는 속도는 빠르다. 그래서 데스크톱 애플리케이션에 적합한 특징이 있다.
- 서버 컴파일러(C2) : 즉시 시작되는 속도는 느리지만 최적화는 많이 되어 초반 이후에는 빠르다. 장기 실행되는 서버 애플리케이션에 적합하다.

HotSpot VM은 Java 7 이전에는 서버, 클라이언트 둘 중 하나를 선택해야 했지만, Java 7부터는 계층형 컴파일을 사용할 수 있는 옵션이 추가되었고, Java 8 부터 계층형 컴파일이 기본 동작이 되었다. 그래서 Java 8 부터는 c1 컴파일러와 c2 컴파일러를 모두 사용한다.

처음에는 c1 컴파일러의 임계값을 초과하면 해당 메소드를 c1 컴파일러 대기열에 넣고 재컴파일하여 최적한다. 이후에도 계속 메소드의 호출 횟수가 증가한다면 c2 컴파일러를 사용한다. 이를 계층형 컴파일(Tiered Compilation)이라고 한다.

```java
1️⃣ 인터프리터 실행
        ↓
2️⃣ 실행 통계 수집 (Profiling)
        ↓
3️⃣ Hot Method 감지
        ↓
4️⃣ C1 컴파일
        ↓
5️⃣ 더 많이 호출되면 C2 재컴파일
```

1. 인터프리터
    - 가장 먼저 실행
    - 메소드 호출 횟수, 분기 통계 수집
2. 프로파일링
    - 메소드 호출 횟수
    - 분기 예측 정보
    - 실제 타입 정보
    - loop 실행 횟수
3. C1
    - 빠르게 컴파일
    - 최적화
    - 빠른 startup
4. C2
    - 고급 최적화 수행
    - 인라이닝
    - Escape Analysis
    - Loop Unrolling
    - Dead Code Elimination

핫스팟은 메소드 호출 횟수 이외에도 OSR, Depotimization이라는 최적화를 수행하는데,

OSR은 루프 실행 중에도 최적화 코드로 교체하는 것을 말하며,
Depotimizaition은 JIT 컴파일러가 가정을 기반으로 최적화를 진행하다가 가정이 깨지만 다시 인터프리터로 되돌리는 과정이다.

## 참고

---

- https://www.artima.com/insidejvm/ed2/introarch3.html
- https://junhyunny.github.io/information/java/jvm-execution-engine/
- https://d2.naver.com/helloworld/1230
- 책 자바의신
- 자바 성능 튜닝 이야기 - story 16 JVM 도대체 어떻게 구동 될까?