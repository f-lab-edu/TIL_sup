# 1. 자바란 ? - 객체지향프로그래밍(OOP) 언어 (정리중)

> 자바는 객체지향 패러다임을 지향하는 언어
Object-oriented programming (OOP) 언어라고 한다.
> 

객체지향 프로그래밍언어
객체지향을 위한 코드 문법을 제공함 (클래스, 인터페이스 등)

OOP(Object-Oriented Programming)는 ‘객체지향’이라는 사고방식(철학)을 **프로그래밍 언어의 문법과 규칙으로 강제·구현한 방법론이다.**

## 자바의 특징

1. 객체지향 프로그래밍 언어
객체지향 프로그래밍이란 현실세계의 사물(객체)들을 프로그래밍으로 옮겨와 객체로 보고, 그 객체로부터 특징과 기능을 프로그래밍하는 기법
2. 운영체제 독립성 (JVM)
자바는 JVM이라는 가상 머신위에 동작한다. OS와 자바사이에 이 JVM이 있어 운영체제의 종류와 상관 없이 프로그램을 실행할 수 있다.
3. 자동 메모리 관리 (GC)
자바는 C언어와 달리 메모리 해제를 직접하지 않는다. 자바의 Garbage Collector가 동적으로 할당한 데이터 중 더 이상 사용하지 않을 경우 자동으로 해제 해준다. GC가 있기 때문에 C언에서 처럼 동적으로 할당하고 해제하는 코드를 작성하지 않아도 된다.

## 1. OOP이란?

객체지향 프로그래밍이란 컴퓨터 프로그램을 어떤 데이터를 입력 받아 순서대로 처리하고 결과를 도출하는 명령어들의 목록으로 보는 시각에서 벗어나 여러 독립적인 부품들의 조합, 즉 객체들의 유기적인 협력과 결합으로 파악하고자 하는 컴퓨터 프로그래밍의 패러다임을 의미한다.

여기서 객채란 뭘까? 객체는 우리가 실제 주변에서 흔히 볼 수 있는 모든 실재하는 대상을 의미한다. 책상, 의자, 시계, 전등, 책 더나아가 철학, 개념, 공식 등 무형의 대상들도 포함될 수 있다. 즉, 객체는 우리가 인지할 수 있는 모든 것을 의미한다고 할 수 있다.

OOP는 이러한 객체들을 프로그래밍으로 구현한 것 이며, 이들 간의 협력을 통해 프로그램을 동작하게 한다.

어떻게 실제 사물을 코딩으로 표현할까? 

예를 들면 이해하기 쉽다. 우리가 컴퓨터, 자동차를 만들 때 무엇이 필요할까. 재료? 부품? 둘다 필요하지만, 정교한 컴퓨터와 자동차를 만들기 위해서는 설계도가 필요하다. 또한, 의자나 책상 이러한 것들도 그냥 만들지는 않을 것이다. 어떠한 공통된 요소가 있는 틀이 있기 때문에 만들 수 있다. 객체지향 프로그래밍도 자동차가 있다면 자동차의 특징과 기능들을 설계도 처럼 나열할 수 있는 것이다.

자바는 **클래스**로 설계를 한다. 클래스에 자동차의 특징을 나열한다. 자동차의 이름과 종류, 속도 등을 정의할 수 있으며, 이것을 상태라고 한다. 그리고 자동차의 출발과 멈춤을 메서드로 정의하는 것을 행위라고 한다. 

### 클래스란 뭘까?

위에서 말한대로 객체를 생성하기 위한 설계도이다. 클래스는 데이터와 그 데이터를 다루는 행위를 하나로 묶은 개념이며, 클래스 내부에는 변수와 메서드가 정의된다. 이 때 변수는 객체의 상태를, 메서드는 객체의 행위를 나타낸다.

**클래스의 상태와 행위**

**상태란?** 
책을 예로 들면 → 펼쳐져 있는 상태, 덮혀 있는 상태, 페이지 수와 같은 책을 나타낼 수 있는 값. 책 이름 등

**행위란?** 
펼치는 행위, 페이지를 넘기는 행위, 덮는 행위
행위 안에 페이지가 넘어가면 페이지 수가 증가하는 로직을 생각할 수 있다.

### 자바는 왜 객체지향을 선택했을까?

그렇다면, 왜 자바는 객체지향을 선택했을까? 객체지향 프로그래밍을 하면서 얻게 되는 장점이 무엇일까?

장점은 많이 있지만 그것에 시작은 복잡도를 줄이기 위함이다. 먼저, 절차지향의 단점부터 살펴봐야하는데 절차지향의 가장 큰 단점은 데이터와 로직인 분리되어 있다는 단점이다. 이렇게 될 경우, 프로그램의 크기가 커지면 커질수록 복잡성이 증가한다.

왜 그럴까? 데이터의 책임이 모호해지기 때문이다. 데이터를 A로직이 사용을 하였고 변경이 되었다. 그런데 다른 B로직이 사용하고 변경이 된다면? A로직이 변경한 값을 어떻게 받아들여야 할까. 이것을 객체지향에서는 책임의 부재로 봤다. 언제든 변할 수 있는 데이터는 예상치 못한 동작을 초래하기 때문이다.

이러한 복잡함을 줄이기 위해서 시작됐다.

절차지향의 복잡성 문제를 해결하기 위해서 새로운 패러다임이 제시된 것이다. 이는 앨런 케이(Alan Kay)에 의해 시작되었으며, 그는 시뮬레이션 프로그래밍 언어인 시뮬라 67에서 영향을 받았으며, 그의 동료들과 최초의 상용화된 객체지향 프로그래밍 언어인 스몰토크를 구현했다.

자바는 애초에 다음 전제를 깔고 출발한다.

- 프로그램은 데이터 + 그 데이터를 다루는 행위의 묶음
- 이 묶음의 최소 단위가 객체
- 객체는 클래스라는 설계도로 부터 생성됨

객체지향은 객체가 중심이되는 철학(사고 방식)이고, 객체지향 프로그래밍은 그 철학을 프로그래밍에 얹은 구현 방식이다.

그러면, OOP는 어떤식으로 문제 해결을 하려 했는가?

## 객체지향의 4가지 특징

객체지향의 4가지 특징은 역할과 책임을 분리해 변경에 강한 구조를 만들기 위한 장치들이다.

### 캡슐화 (Encapulation)

캡슐화란 객체의 내부 상태와 구현을 외부로부터 숨기고 허용된 방법(메서드)으로만 접근하게 만드는 것이다.

내부 구현 변경이 외부 코드에 영향을 주지 않도록 격리하고, 객체 스스로 자기 상태를 책임지게 한다. 중요한 것은 private 키워드가 아니라 “무엇을 숨길 것인가”가 핵심이다.

### 추상화 (**Abstration**)

추상화란 어떠한 사물들의 공통적인 특징과 기능만을 추출하고 불필요한 세부 구현음 숨겨 단순화하는 과정이다. 이는 정보의 복잡도를 줄여 이해와 관리를 쉽게 만들 수 있다. 가장 좋은 예시로 지하철 노선도를 볼 수 있다. 지하철 노선도는 복잡한 지하철의 노선의 지리를 추상화시켜서 사람들이 쉽게 이해할 수 있게 단순화한 대표적인 예시이다.

OOP 또한 객체의 공통적인 속성과 기능을 추출하여 정의하는 것을 의미한다.

추상화는 구현이 아니라 의도와 역할에 의존하게 만들기 위해서 변경 가능성을 인터페이스 뒤로 숨긴다.

“이 객체는 무엇을 할 수 있는가”를 생각해야한다. 흔한 오해로 추상클래스/인터페이스를 쓰면 추상화라고 하지만 아니다. 적절한 책임 경계를 생각해야한다. 코드 문법은 수단일 뿐이다.

### 상속 (Inheritance)

기존 객체의 책임과 행위를 재사용하거나 확장하는 메커니즘이다. 상속이 필요한 이유는 중복 코드를 제거하고, 공통 개념의 계층 표현을 위해 필요하다. 그러나 상속은 잘못 쓰면 오히려 강한 결합을 불러올 수 있다. 그래서 상속은 “is-a” 관계일 때만, 매우 제한적으로 사용해야하고, 실무에서는 상속보다 합성을 사용한다.

### 다형성 (Polymorphism)

같은 메시지에 대해, 객체마다 다른 행동을 하는 능력이다. 다형성이 필요한 이유는 조건문 제거, 새로운 기능 추가 시 기존 코드 수정을 최소화할 수 있다.

객체지향은 다형성이 있어야 OCP(개방-폐쇄 원칙) 플러그인 구조 전략 교체가 가능해진다. 오버로딩이 다형성이 아니라 런타임 디스패치가 핵심이다. 객체지향으로 프로그래밍할 때는 클래스보단 실제 동작시 객체가 하는 행위와 협력에 대해서 생각해야 하는 이유이다.

이 4개는 독립된 개념이 아니고 연결되어 있다. 다형성을 쓰기 위해 추상화가 필요하고, 추성화를 안전하게 쓰려면 캡슐화가 필요하다. 상속은 선택지 중 하나일 뿐이다.

객체지향의 4가지 특징은 객체를 독립적인 책임 단위로 만들고, 구현 변경이 시스템 전체로 확산되는 것을 막기 위한 설계 원칙들이다.

---

## 객체지향 설계 원칙 (SOLID 원칙?)

객체지향 설계 원칙은 Robert C. Martin에 의해 제안되었다. 객체지향 설게를 유지보수 가능하게 만드는 최소 조건을 정리한 원칙 묶음이다.

객체지향 설계 원칙의 목적은 변경에 강한 구조, 확장 가능하지만 수정은 최소화, 테스트 대체 재사용이 쉬운 코드를 목적으로 한다.

### SRP(Single Responsibility Principle)

단일 책임 원칙

하나의 클래스는 하나의 변경 이유만 가져야 한다. SRP는 메서드가 하나가 아니라 책임이 하나를 의미한다.

만약, 하나의 클래스가 비즈니스 규칙, DB 매핑, 외부 API 포맷을 도시에 다룬다면 SRP를 위반한 클래스이다. 즉, SRP는 변경의 축을 분리하는 원칙이다.

### OCP(Open-Closed Principle)

개방 폐쇄 원칙

확장에는 열려 있고, 수정에는 닫혀 있어야 한다는 원칙이다.

새로운 요구사항이 왔을 때 기존 코드는 수정하지 않고 새로운 구현이 추가되어야 한다. 이는 인터페이스, 다형성, 전략 패턴을 통해서 구현할 수 있다. OCP는 if else, switch를 줄여주는 원칙이기도 하다. 그래서 if else, switch가 계속 늘어난다면 개방 폐쇄 원칙에 위반되지 않는지 생각해볼 수 있다.

### LSP(Liskov **Substitution** Principle)

리스코프 치환 원칙

자식 객체는 부모 객체를 완전히 대체할 수 있어야 한다. 리스코프 치환 원칙은 컴파일이 아니라 의미의 문제이다. 상속 관계에서 약속에 대한 원칙이다.

부모에서는 가능한 동작이 자식에서는 예외를 던지거나, 입력 범위와 출력 의미를 좁힌다면 LSP위반하는지 생각해봐야 한다. LSP가 깨지면 상속은 재앙이 된다.

### ISP(Inteface Segregation Principle)

인터페이스 분리 원칙

사용하지 않은 메서드에 의존하도록 강요받아서는 안 된다 ISP는 큰 인터페이스 하나가 아니라 작고 목적이 명확한 인터페이스 여러 개를 의미한다. 즉, 인터페이스로 책임을 부여를 하지만 인터페이스에 여러 책임을 들어있으면 안된다.

### DIP(Dependency Inversion Principle)

의존성 역전 원칙

고수준 모듈은 저수준 모듈에 의존하면 안 된다. 둘 다 추상황에 의존해야 한다. 핵심은 객체 생성이 아니라 의존성의 방향이다.

**DIP 위반 예시**

```java
class OrderService {
    private final CardPayment payment = new CardPayment();

    void pay() {
        payment.pay();
    }
}

// 의존성 구조
// OrderService ───▶ CardPayment
```

- 결제 수단이 바뀌면 OrderService가 수정되어야 한다.
- 테스트시 실제 CardPayment가 필요하다
- 고수준 정책(CardService)가 저수준 구현(CardPayment)에 끌려다닌다.

```java
interface Payment {
    void pay();
}

class CardPayment implements Payment {
    public void pay() { }
}

class OrderService {
    private final Payment payment;

    OrderService(Payment payment) {
        this.payment = payment;
    }

    void pay() {
        payment.pay();
    }
}

// 의존성 구조
OrderService ───▶ Payment ◀─── CardPayment
```

중요한 점은

- CardService는 CardPayment를 모른다.
- CardPayment 또한 CardService를 모른다.

DIP원칙을 지키면 구현 교체가 쉬워지고, 테스트가 쉬워진다. 그리고 변경이 국소화된다.

```java
new OrderService(new AccountPayment());
new OrderService(new PointPayment());
```

```java
class FakePayment implements Payment {
    public void pay() { /* 테스트용 */ }
}
```

> DIP의 결과는
고수준 정책 코드가 저수준 구현 변경으로부터 독립되는 것
> 

### **절차지향?**

프로그램일 일련의 순차적인 처리 과정으로 보고, 프로그램 전체가 유기적으로 연결되도록 만드는 프로그래밍 기법이다. 대표적으로 c언어를 생각해보자. (DB에는 프로시저가 절차지향…, 쿼리는 선언형…ㅋ)

- 데이터를 함수가 처리한다. “무엇을 어떤 순서로”

```jsx
pay(order, method) 같은 함수가 있다면,

switch(method)문을 통해 카드/계좌/포인트 분기 처리
- 기능 추가시 분기가 추가됨
```

이렇게 c언어 처럼 중요 로직이 한 곳에 있을 경우, 나중에 기능 추가 등 확장하기가 어려워짐.

또한 기존 로직을 수정해야한다면, 가독성이 좋지 않아 수정하기 어려워진다. 그리고 혹시나 수정한 곳이 다른 기능에 예상하지 못한 영향을 줄 수 있기 때문에 유지보수하기 힘들어진다.

이러한 이유로 c언어는 빠르지만, 코드 재사용성 및 확장성이 부족하고 데이터와 로직의 분리로 인한 복잡성이 증가해 대규모 프로젝트에 적합하지 않다.

---

- 정리
    
    클래스가 뭔가요?
    → 객체를 생성하기 위한 설계도. 즉, 클래스가 없인 객체를 생성할 수 있다. OOP의 핵심 요소 중 하나
    클래스는 객체의 상태와 행위를 나타내기 위한 코드 문법이다.
    
    메소드가 뭔가요?
    → 메소드는 자바 객체에서 행위를 나타내며, 메서드 안에서 일련의 논리적인 과정을 코드로 구현할 수 있습니다. 자바에서 메소드는 객체간의 관계를 이어주는 메세지 전달 역할을 합니다.
    
    메소드의 매개 변수는 어디에 적어주나요?
    → 메소드의 매개 변수는 메소드명 바로 뒤에 () 안에 적어주고 매개 변수가 여러 개라면 반점으로 구분합니다.
    
    클래스가 갖고 있어야 한다고 한 두 가지가 뭐죠?
    → 클래스가 가지고 있어야 하는 것은 상태(변수), 행위(메서드)입니다.
    
    메소드에서 결과를 돌려주려면 어떤 예약어를 사용해야 하나요?
    → 메소드에서 결과를 돌려주려면 return 이라는 예약어를 사용하면 됩니다. 그리고 반환하는 값에 타입을 메서드 선언부 맨 앞에 적어주어야 컴파일이 에러가 나지 않습니다.
    

Enum에도 SRP가 지켜져야 하는가?

Enum의 본질부터 정리

- 닫힌 집합(Closed Set)
- 상태 없음 또는 매우 제한된 상태
- 값 + 값에 대한 정책(행위)를 함께 묶기 좋다.

다음에 코드가 SRP 위반인 이유

```java
enum OrderStatus {
    READY {
        @Override boolean canCancel() { return true; }
        @Override String toApiValue() { return "R"; }
        @Override void validate(Order o) { ... }
    },
    DONE {
        @Override boolean canCancel() { return false; }
        @Override String toApiValue() { return "D"; }
        @Override void validate(Order o) { ... }
    };

    abstract boolean canCancel();     // 비즈니스 규칙
    abstract String toApiValue();     // 외부 시스템 표현
    abstract void validate(Order o);  // 검증 로직
}
```

1. 비즈니스 규칙 변경
2. 외부 API 스펙 변경
3. 검증 정책 변경

Enum 하나가 여러 정책의 중심이 된다.

---

OOP가 필요한 몇 가지 주요 이유는 다음과 같다.  
1. 모듈화 : OOP는 프로그래머가 복잡한 문제를 객체라고 불리는 더 작고 관리하기 쉬운 조각으로 분해할 수 있도록 하는 모듈화 코드의 개발을 촉진한다. 각 개체는 개체의 속성 및 동작을 정의하는 클래스의 인스턴스이다. 이러한 모듈화를 통해 대규모 소프트웨어 시스템을 보다 쉽게 이해, 개발 및 유지관리할 수 있다.  
2. 캡슐화 : OOP에서는 해당 데이터에 대해 작동하는 데이터와 함수가 객체라고 하는 하나의 단위로 번들된다. 이러한 데이터와 동작의 캠슐화는 문제를 명확하게 구분하여 코드에 대한 추론을 용이하게 하고 시스템의 다른 부분 간의 의도하지 않은 상호 작용을 방지한다.  
3. 재사용 가능성 : OOP는 재사용 가능한 구성요소를 만들 수 있도록 지원한다. 이 구성요소는 다른 시스템에 쉽게 통합되거나 새로운 목적에 맞게 조정될 수 있다. 이는 기존 클래스에서 새 클래스를 파생하여 필요에 따라 추가하거나 수정하는 동시에 해당 속성과 동작을 상속할 수 있다. 이는 코드 중복을 줄이고 재사용 가능한 라이브러리 및 프레임워크의 개발을 촉진한다.  
4. 추상화 : OOP는 프로그래머들이 더 높은 수준의 추상화 작업을 할 수 있게 해주며, 더 낮은 수준의 작업의 복잡성을 숨긴다. 이를 통해 개발자는 문제의 본질적인 기능에 집중할 수 있으며 기본 구현 세부 정보는 개체 자체에서 관리할 수 있으므로 개발 프로세스가 간소화된다.  
5. 다형성 : OOP는 다형성을 지원하므로 다른 클래스의 객체를 공통 슈퍼클래스의 객체로 취급할 수 있다. 이를 통해 동일한 인터페이스나 코드 구조를 사용하여 서로 다른 개체 유형을 처리할 수 있으므로 보다 유연하고 확장 가능한 코드를 작성할 수 있다.  
    
출처 : [https://www.codestates.com/blog/content/객체-지향-프로그래밍-특징](https://www.codestates.com/blog/content/%EA%B0%9D%EC%B2%B4-%EC%A7%80%ED%96%A5-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%ED%8A%B9%EC%A7%95)


## 꼬리 질문

> 1장에서 저자가 말하는 **“자바가 다른 언어보다 유지보수에 강하다”**는 주장,
네 말로 딱 한 문장으로 요약해보면 뭐라고 할 수 있을까?
>

자바가 다른 언어보다 유지보수에 강한 이유는 자바가 객체지향 언어이기 때문에 그렇다.

> “객체지향이라서 유지보수에 강하다”에서
>
>
> **객체지향의 어떤 성질**이 유지보수에 직접적으로 기여한다고 봐?
>
> - 캡슐화
> - 상속
> - 다형성
> - 역할과 책임 분리
>
> 이 중 **딱 하나만** 골라서 이유를 말해봐. (왜 다른 건 제외했는지도 함께)
>

역할과 책임 분리이다. 역할과 책임 분리한다는 말은 결합도를 낮추고 응집도를 높인다. 응집도는 모듈의 독립성을 나타내고 결합도는 외부의 모듈과의 연관도를 나타낸다. 이렇게 되면 하나의 모듈(책임)은 다른 역할에 부여할 수 있고 있는 재사용성으로 이어진다. 또한, 이러한 특성은 오로지 자신의 역할과 책임만 신경쓰면 되기 때문에 다른 모듈간의 영향도는 신경쓰지 않아도 되어 확장이 되거나 수정하기가 용이하다.

다른 성질을 제외한 이유는 캡슐화, 상속, 다형성이 되어야 역할과 책임을 분리할 수 있기 때문이다.
즉, 역할과 책임 분리에 다른 성질들이 녹아들어 있다.

<aside>
💡

“응집도는 모듈의 독립성을 나타낸다”

반만 맞는 정답.

- 응집도 : 모듈 내부 요소들이 얼마나 한 목적에 집중되어 있는가
- 독립성은 응집도 + 낮은 결합도의 결과

다시 말해서,
응집도 = 내부 집중도
독립성 = 외부 영향에서의 자유

</aside>

> 1장에서 저자가 C 같은 절차지향 언어를 은근히 비교 대상으로 두는데,
>
>
> **절차지향 코드에서 유지보수가 어려워지는 순간**은 보통 어떤 상황일까?
>
> 네가 겪었거나, 겪었을 법한 상황으로 말해봐.
>

절차지향 코드에서 유지보수가 어려워지는 경우는 프로그램이 거대 해질 때이다. 프로그램 전체가 유기적으로 연결되어 있기 때문에 프로그램 코드의 양이 늘어나면 늘어날 수록 복잡도가 증가한다. 즉, 데이터와 로직이 분리되지 않아, 변경이 흐름 전체를 건드리게 된다. 예를 들어 switch 문으로 분기처리할 때 혹시라도 분기 처리가 계속 늘어난다면 유지보수 하기 쉽지 않아진다.

> 지금 네 답변에는 이런 전제가 숨어 있어:
>
>
> > “객체지향으로  *잘* 짜여 있다면 유지보수가 쉽다”
> >
>
> 그렇다면 반대로 질문할게.
>
> **자바인데도 유지보수가 지옥이 되는 코드**는 어떤 특징을 가질까?
>

자바인데도 유지보수가 지옥이 되는 코드는 자바를 절차지향적으로 코딩할 경우이다.
객체지향은 설계를 잘 한다면 유지보수하기 쉬워지지만 설계를 하기가 어렵다. 그렇기 때문에 대부분의 자바 개발자들이 객체지향의 특성을 이해하지 못하고 절차지향적으로 짜는 개발자들이 많다. 하나의 메서드의 여러 책임을 부여를 하는 경우도 있을 수 있고, 하나의 클래스에 인스턴스 변수를 너무 많이 선언하는 경우도 있다. 책임이 많다는 건 변경 이유가 많아진다는 뜻이다. 그렇게 되면 클래스의 크기가 커지고, 복잡도 증가하며 유지보수가 힘들어진다.